webpackJsonp([80206209890701],{590:function(n,s){n.exports={data:{markdownRemark:{excerpt:"Most Javascript developers get by without ever having to understand closures.\nYou could get by without closure, but developing an understanding of closures\nwill allow you to unlock more of Javascript's potential. In an effort to prepare myself for CSâ€¦",html:'<p>Most Javascript developers get by without ever having to understand closures.\nYou could get by without closure, but developing an understanding of closures\nwill allow you to unlock more of Javascript\'s potential.</p>\n<p>In an effort to prepare myself for CS3216, I spent the last two weeks refreshing\nmy javascript knowledge. Having heard stellar reviews of the <a href="https://github.com/getify/You-Dont-Know-JS">You Don\'t Know\nJS</a> series, I decided to dive deep\ninto it hoping to develop a more complete understanding of the world\'s most\nmisunderstood language.</p>\n<p>In this blog post series, I will share some of the insights that I have\ndeveloped studying the book series. I will attempt to explore concepts in an\njavascript-experience agnostic manner for the benefit of non javascript\ndevelopers.</p>\n<p>Let\'s get started.</p>\n<h3>Closures</h3>\n<p>Most Javascript developers get by without ever having to understand closures.\nYou could get by without closure, but developing an understanding of closures\nwill allow you to unlock more of Javascript\'s potential. To gain a deep\nunderstanding of closures, let us begin from the bottom.</p>\n<h5>Javascript is compiled</h5>\n<p>While Javascript behaves like an interpreted language, it is in fact compiled.</p>\n<h5>Lexical scoping vs Dynamic scoping</h5>\n<p>The implications of Javascript being compiled is that it has two scopes:</p>\n<ul>\n<li>Lexical scope - the scope of a function during compile time.</li>\n<li>Dynamic scope - the scope of a function during run time.</li>\n</ul>\n<p>While interpreted languages only have a dynamic scope to worry about, compiled\nlanguages have to juggle both the dynamic and interpreted scopes.</p>\n<p>For the benefit of those who do not understand scopes, the scope is the list of\nenvironments that the function has access to. Let me illustrate this concept\nusing the below code snippet.</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-javascript"><code><span class="token string">"use strict"</span><span class="token punctuation">;</span>\n\n<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token string">"b"</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//prints \'b\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">bar2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//prints \'a\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">bar2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//prints \'a\'</span>\n</code></pre>\n      </div>\n<p>On top of having access to their own scopes, the functions bar and bar2 both\nhave access to the global scope. This is why function bar2 is able to print foo\nas \'a\' even though foo is not declared explicitly within bar2.</p>\n<h5>Closures</h5>\n<p>In Javascript, functions are first-class citizens. This means that Javascript\nsupports the passing of functions as arguments into other functions.</p>\n<p>Closures are the result of two of Javascripts properties:</p>\n<ul>\n<li>Compiled (thus, having compile time and run time scopes)</li>\n<li>First-class functions (thus, able to execute functions outside of their\nlexical scope)</li>\n</ul>\n<p>Closures occur when a function is being executed outside of its lexical scope.\nIn a closure, a function remembers its lexical scope even when executed outside\nof its lexical scope.</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-javascript"><code><span class="token string">"use strict"</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token string">"bar"</span><span class="token punctuation">;</span>\n  <span class="token keyword">function</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">bam</span><span class="token punctuation">(</span>baz<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">bam</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//prints "bar"</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>In the above example, the function baz is being passed out of the function foo\ninto the global function bam. On line 12 when we execute the function func(), we\nare still able to access the lexical scope of function baz even though func is\nbeing executed outside of the lexical scope of baz.</p>\n<p>While closures seem obvious enough when we program synchronously, it begins to\nget tricky once we program asynchronously.</p>\n<h5>When closures get tricky - Requires some Javascript experience</h5>\n<p>Observe the below asynchronous code snippet:</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>What does it print?</p>\n<ul>\n<li>Most developers would guess [1,2,3,4,5], but it actually prints [6,6,6,6,6].\nTest it out yourself to be convinced of this.</li>\n</ul>\n<p>Why do we not get [1,2,3,4,5]?</p>\n<ul>\n<li>For each iteration of the loop, we call an asynchronous function over the same\nexact global scope. There is no new scope created within each iteration of the\nloop. Hence, all of the functions print 6 since they are enclosed by the same\nglobal scope.</li>\n</ul>\n<p>So how do we get the asynchronous functions to print [1,2,3,4,5]?</p>\n<h5>Solution 1 : The Let keyword</h5>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>The let keyword (<a href="https://github.com/lukehoban/es6features">introduced in ES6</a>)\ncreates a new closure within each iteration of the loop. Hence, each of the\nasynchronous functions are enclosed within a different dynamic scope.</p>\n<h5>Solution 2: Immediately Invoked Function Expressions (IIFE)</h5>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>For those who are not familiar with function expressions and IIFEs, read\n<a href="http://adripofjavascript.com/blog/drips/an-introduction-to-iffes-immediately-invoked-function-expressions.html">this</a>.</p>\n<p>Similiar to the let keyword, IIFEs also allows us to enclose each iteration of\nthe loop within a different dynamic scope.</p>',frontmatter:{date:"August 08, 2017",path:"closures",title:"You Don't Know JS (1) - Closures"}}},pathContext:{id:"closures"}}}});
//# sourceMappingURL=path---blog-closures-44e41bd0ae289ce25af4.js.map