webpackJsonp([0x8039df25e889],{603:function(e,n){e.exports={data:{markdownRemark:{excerpt:"As part of my thesis requirement, I decided to research and implement a data\ngenenerator. This post houses a current draft of my thesis report. Abstract Data generators are instrumental in any software testing and database\nbenchmarking processâ€¦",html:'<p>As part of my thesis requirement, I decided to research and implement a data\ngenenerator. This post houses a current draft of my thesis report.</p>\n<h2>Abstract</h2>\n<p>Data generators are instrumental in any software testing and database\nbenchmarking process. Developing data generators, however, is a complex task.\nWhile most developers have a conceptual understanding of their desired dataset,\nthey face difficulty translating their conceptual understanding into the billion\nrows of test data that they are required to generate.</p>\n<p>This paper presents a highly-extensible and modular data generation tool that\nsimplifies the process of generating realistic test data. The tool also promotes\ncode reuse, sharing and refinement through enforcing a consistent modular\ninterface.</p>\n<p>The tool abstracts generic/complex concerns - such as fast random number\ngeneration, and task scheduling - away from developers, enabling them to invest\ntheir efforts in declaring how their data should look like.</p>\n<h2>1. Introduction</h2>\n<p>Database benchmarks while robust are tested using stock schemas. Such benchmarks\nprovide developers with a good estimate of their database system\'s general\nperformance. They are, however, unable to provide developers with the following:</p>\n<ul>\n<li>Their database system\'s performance when tested using their own custom\nschemas.</li>\n<li>Their database system\'s performance when schema is normalized and\ndenormalized.</li>\n<li>Realistic test data [FOOTNOTE: meaningful data with statistical properties\nthat approximate a production environment] for backend stress testing.</li>\n<li>Realistic test data for usability acceptance testing.</li>\n</ul>\n<p>Such highly-specific information can only be derived through developing custom\ndata generators to populate the custom schema with realistic test data.</p>\n<p>While there are many general-purpose data generators available in industry,\ntheir low degree of customizability do not allow developers to generate\nrealistic datasets which often exibit rich intra-row[FOOTNOTE: data dependencies\nacross a single row], intra-column[FOOTNOTE: data dependencies down a single\ncolumn], and inter-table[FOOTNOTE: data dependencies across a foreign-key\nrelation] correlations. As such, many developers resort to developing their\ncustom data generators from scratch. These data generators, however, are often\ninflexible, tedious to produce, and difficult to reuse.</p>\n<h3>1.1 Claims &#x26; Contributions</h3>\n<p>This paper introduces Spawn, a highly-extensible and modular data generation\ntool developed in javascript. Spawn consists of:</p>\n<ul>\n<li>A core library that manages the complexities of generating realistic datasets.</li>\n<li>An extension suite that allows developers to extend Spawn with their own\ncustom logic.</li>\n<li>A Graphical User Interface (GUI) that makes Spawn easier to use.</li>\n</ul>\n<p>Spawn is based upon two fundamental structures:</p>\n<ul>\n<li>A modular architecture that demarcates a clear seperation of concerns between\nSpawn\'s core library and its extension suite.</li>\n<li>A graph model that enables Spawn to generate data with complex <u><strong>inter-row\nand</strong></u> intra-table relationships.</li>\n</ul>\n<h3>1.2 Outline</h3>\n<p>This paper first discusses related work in (Section 2), then articulates the\ndesirable qualities of a data generator in (Section 3).</p>\n<p>With those qualities articulated, the paper then:</p>\n<ul>\n<li>Provides a structural overview of Spawn\'s modular architecture in (Section 4)</li>\n<li>Introduces Spawn\'s graph model in (Section 5)</li>\n<li>Explains Spawn\'s graphic design principles in (Section 6)</li>\n<li>Summarizes how Spawn generates data quickly in (Section 7)</li>\n</ul>\n<p>Finally, the paper will compare Spawn against other data generators based on\nthree key criteria in (Section 8):</p>\n<ol>\n<li>Expressiveness</li>\n<li>Ease of configuration</li>\n<li>Speed</li>\n</ol>\n<h2>2. Related work</h2>\n<p>Since the development of DBGEN [FOOTNOTE - the first data generator developed by\nthe Transaction Processing Performance Council (TPC)] in 1992, frameworks and\ntechniques for generating data have been explored substantially across academia\nand industry.</p>\n<h3>2.1 Academic work</h3>\n<p>Significant research have been conducted on improving the speed of data\ngeneration. [Grey et al, 1994] presented a technique that allows for fast,\nparallel generation of data in linear time. The limitation with Grey\'s model is\nthat the number of processors participating in the parallel data generation\nprocess is fixed from the start. [Rabl et at, 2010] solved this limitation by\nproposing a technique that allows for linear scaling for arbitrary number of\nprocessors.</p>\n<p>Techniques for improving the expressiveness of data generators have also been\nexpored. [Bruno &#x26; Chaudhari, 2005] presented a flexible and easy to use\nframework for data generation. Their research introduced a graph-based\nevaluation model which is capable of modelling data distributions with rich\nintra-row and inter-table correlations. [Houkjaer et al, 2006] also presented a\nsimilar graph-based model but diverges from Bruno &#x26; Chaudhari\'s model by\nallowing intra-column dependencies at the cost of enforcing sequential data\ngeneration.</p>\n<h3>2.2 Industry work</h3>\n<p>Industrial data generators fall into two categories: General and Specific.\nSpecific data generators are designed to produce a predefined data set used for\nbenchmarking purposes. General data generators on the other hand offer\ndevelopers the ability to customize the data they need.</p>\n<h4>2.2.1 Specific data generators</h4>\n<p>Most industial data generators fall into the specific category. Notable\ngenerators include DBGEN for TPC-H benchmarking [Poess &#x26; Floyd, 2000] and MUDD\nfor TPC-DS benchmarking [Stephens &#x26; Poess, 2004].</p>\n<p>While specific data generators are usually extremely fast and highly-expressive,\nthey can only generate a predefined data set which makes it unsuitable for\nusability testing and backend stress testing purposes. Both testing paradigms\nrequire data generated specifically for the software being tested.</p>\n<h4>2.2.2 General data generators</h4>\n<p>General data generators on the other hand suffer from the opposite problem. They\noffer developers with a fair degree of customizability but sacrifice\nexpressiveness and speed.</p>\n<p>At the time of writing this paper, the five most popular general data generators\navailable - <a href="http://www.mockaroo.com/">Mockaroo</a>,\n<a href="http://www.freedatagenerator.com/">FDG</a>, <a href="http://www.sqledit.com/dg/">DTM</a>,\n<a href="https://www.red-gate.com/products/sql-development/sql-data-generator/index">Red\nGate</a>,\nand <a href="https://www.generatedata.com/">Generate Data</a> - were analysed for their\ncapabilities.</p>\n<p>Mockaroo, FDG, and Generate Data offer great row-wide data generators with\nresults of high variability. They also allow data to be exported in multiple\nformats, such as CSV, JSON, XML, and SQL.</p>\n<p>However, they do not allow developers to insert their own custom logic, or\nperform seeded data generation.</p>\n<p>Red Gate and DTM, on the other hand, offers seeded data generation, and the\nability to insert custom logic.</p>\n<p>They, however, comes at a price of $369 and $149 per license respectively.</p>\n<p>While all of the above-mentioned general data generators offer intra-row data\ndependencies, none of them allow for intra-column or inter-table data\ndependencies. They also do not afford parallel data generation.</p>\n<h2>3. Desirable qualities</h2>\n<p>In this section we examine some of the qualities that users of data generators\nare likely to desire. We define two categories by which we analyze the qualities\nof data generators.</p>\n<p>The first category is concerned with how users want their data generators to\nperform. We define this category as performance qualities (Section 3.1) and it\nencompasses qualities such as:</p>\n<ul>\n<li>(Section 3.1.1) Statistically representative data</li>\n<li>(Section 3.1.2) Repeatable data generation</li>\n<li>(Section 3.1.3) Time and space performance</li>\n<li>(Section 3.1.4) Parallel data generation</li>\n<li>(Section 3.1.5) High data generation periodicity</li>\n</ul>\n<p>The second category is concerned with how users want to develop on their data\ngenerators. We define this category as development qualities (Section 3.2) and\nit encompasses qualities such as:</p>\n<ul>\n<li>(Section 3.2.1) Code reusability (Reuse components for diff needs)</li>\n<li>(Section 3.2.2) Ease of configurability</li>\n<li>(Section 3.2.3) Declarative and functional style programming</li>\n</ul>\n<p><strong>IN INTEREST OF COMPLETING THIS DRAFT THIS SECTION IS TRUNCATED</strong></p>\n<h2>4. Spawn: Architecture</h2>\n<p>Spawn has a simple architecture that consists of a core and an extension suite.\nThis section will first demonstrate how the Spawn Extension Suite allows\ndevelopers to extend Spawn using their own custom logic before articulating how\nSpawn Core orchestrates the data generation process.</p>\n<p><img src="https://aaronong.github.io/SpawnArchitecture5.png" alt="Spawn Architecture"></p>\n<h3>4.1 Spawn Extension Suite</h3>\n<p>Spawn Extension Suite provides all the tools required to make extending Spawn as\nsimple as possible.</p>\n<h4>4.1.1 Data Types</h4>\n<p>The Data Types component outlines the Spawn type system and provides an\nubiquitous Type Checking mechanism for all Spawn extensions.</p>\n<p>All extensions developed in Spawn are required to implement the types defined by\nthe Data Types component.</p>\n<h4>4.1.2 Field Value Generators (FVG)</h4>\n<p>While Data Types and Testing Suite are supporting tools developed to make\nextending Spawn as simple as possible, FVGs are the actual extensions that\ndevelopers develop for Spawn.</p>\n<p>FVGs are categorized by their output type:</p>\n<ul>\n<li>Number generators generate numbers.</li>\n<li>String generators generate strings.</li>\n<li>Boolean generators generate booleans.</li>\n<li>Datetime generators generate datetime.</li>\n</ul>\n<p>With the exception of Datetime generators which are often required to generate\ndatetimes based on the current time, Spawn enforces that all FVGs are pure\nfunctions for the following reasons:</p>\n<ul>\n<li>The RNG in Spawn Core abstracts the task of generating fast and repeatable\nrandomness away, allowing FVGs to generate random data while staying pure.</li>\n<li>Pure functions have more predictable behavior.</li>\n<li>Pure functions are easier for developers to reason about.</li>\n<li>Prevent developers from implementing their own random number generators which\nare prone to errors, poor performance, or poor statistical properties.</li>\n<li>Allows Spawn to generate identical data across multiple runs.</li>\n</ul>\n<p>FVGs have access to the following inputs:</p>\n<ul>\n<li><code>rn</code> - a random floating point number uniformly distributed in the range of\n[0,1).</li>\n<li><code>id</code> - the row id of the field being generated.</li>\n<li>\n<p><code>lastN</code> - the list of fields generated by the FVG with ids in the range of\n<code>[id - N, id - 1]</code>. <code>N</code> can be specified by the FVG\'s developer.</p>\n<ul>\n<li><code>lastN</code> allows developers to generate data with intra-column data\ndependencies.</li>\n</ul>\n</li>\n<li>\n<p><code>rowData</code> - Given that the current FVG generates data for column <code>x</code>,\n<code>rowData</code> is the list fields generated in the same row from columns <code>[1, x - 1]</code>.</p>\n<ul>\n<li><code>rowData</code> allows developers to generate data with intra-row data\ndependencies.</li>\n</ul>\n</li>\n<li>\n<p><code>foreignData</code> - Given that the current row (R1) being generated is associated\nwith another row (R2) through a foreign key, <code>foreignData</code> provides R1 with\naccess to the list of all values generated in R2 provided that R2 has already\nbeen generated.</p>\n<ul>\n<li><code>foreignData</code> allows developers to generate data with intra-table data\ndependencies.</li>\n</ul>\n</li>\n<li><code>userParameters</code> - FVGs may optionally require user-provided parameters to\ngenerate data. eg. a number generator that generates normal distributions will\nrequire that users provide the mean and standard deviation.</li>\n</ul>\n<p>Spawn provides developers with a simple way to gather the data they require for\ngenerating realistic data. This structure makes developing FVGs a much simpler\ntask in Spawn as compared to other data generation tools.</p>\n<h4>4.1.3 Testing Suite</h4>\n<p>This component provides an exhaustive list of tests to ensure that developed\nextensions are compliant with Spawn\'s requirements. Extensions that pass the\ntests defined in the testing suite are guaranteed to function properly within\nSpawn.</p>\n<p>The testing suite provide developers with the ability to check for their\nextension\'s compliance without loading it into the Spawn GUI. This substantially\nshortens development time, and is likely to improve Spawn\'s extension\ndevelopment experience.</p>\n<h3>4.2 Spawn Core</h3>\n<p>The previous subsection revealed an extension system that allows for generating\nhighly-expressive and realistic test data in a convenient fashion. This\nsubsection will summarize the components in Spawn Core that powers the\nexpressive capabilities observed in Spawn\'s FVGs.</p>\n<h4>4.2.1 Graph Model</h4>\n<p>Data across a single row is always generated from left to right. Data down a\nsingle column is generally generated from top to bottom. (FOOTNOTE: exceptions\nonly occur in parallel computation models) How about data across different\ntables?</p>\n<p>The Graph Model dictates the order by which data is generated across different\ntables in the schema. It powers the <code>foreignData</code> input available in FVGs. More\ndetails will be explained in (Section 5).</p>\n<h4>4.2.2 Random Number Generator(RNG)</h4>\n<p>Spawn\'s RNG is implemented using the <code>PCG-XSH-RR</code> RNG which belongs to the\npermuted congruential generator (PCG) family of random number generators\n[O\'Neill, 2014]. It was selected for the following reasons:</p>\n<ul>\n<li>\n<p>Seeded - allows for identical RNG sequences to be generated across different\nruns</p>\n<ul>\n<li>able to generate Identical datasets for benchmarking</li>\n</ul>\n</li>\n<li>Fast - Generates next state at a very low constant cost</li>\n<li>\n<p>Logarithmic access times - able to jump ahead to the $n_{th}$ number in the\nRNG sequence in $log(n)$ time.</p>\n<ul>\n<li>Algorithm developed by [Brown et al, 1994]</li>\n</ul>\n</li>\n<li>\n<p>High periodicity - A period of $2^n$ where $n$ is the number of bits used to\nstore the state.</p>\n<ul>\n<li>Spawn utilizes a good multiplier constant proposed by [L\'ecuyer, 1999] to\nensure good lattice structure.</li>\n<li>Spawn uses a 64-bit implementation.</li>\n</ul>\n</li>\n</ul>\n<p>By abstracting the task of generating random numbers out into a self-contained\nfunction, Spawn allows FVGs to generate random data while staying pure.</p>\n<h4>4.2.3 Postprocessor</h4>\n<p><img src="https://aaronong.github.io/spawnArchitecture.png" alt="Spawn Architecture"></p>\n<p>Data generated by an FVG can be optionally fed into a post-processor which\nperforms a final alteration to the generated data. The post-processing step\nallows FVGs to be more versatile and encourages code reuse.</p>\n<p>For instance, a floating point generator could be repurposed as an integer\ngenerator by providing a post-processor that rounds floating point outputs to\nits nearest integer.</p>\n<p>A email string generator could be repurposed as an email domain name generator\nby allowing developers to specify their custom regex to pull out the domain\nname.</p>\n<h4>4.2.4 Data Log</h4>\n<p>The data log is simply a temporary flat file that stores all the generated data\nbefore it is ready to be exported by Spawn. While it is a simple concept, it is\nextremely powerful. The data log is what affords FVGs the <code>rowData</code> and <code>lastN</code>\ninputs.</p>\n<h4>4.2.5 Configurations management</h4>\n<p>Each data generator project contains complex configurations that Spawn will need\nto persist across different sessions. Hence, Spawn uses an XML file to store all\nof the configurations that describes a data generator project. This enables\nconfigurations to be saved, loaded, and shared between computers. It also\naffords Spawn the option of adopting a client-server architecture in the future.</p>\n<p>A client-server architecture will allow Spawn to:</p>\n<ul>\n<li>Capitalize on the multiple cores available on servers to generate data in\nparallel.</li>\n<li>Enjoy performance benefits by employing systems level language such as Golang\nor C++ to generate data on the backend. Generating data on the frontend is\nlimited by Javascript\'s relatively poorer performance.</li>\n</ul>\n<p>Spawn\'s configurations management file is similar to the meta-generators\nproposed by [Rabl et al, 2013].</p>\n<h4>4.2.6 Database interface</h4>\n<p>The database interface controls how Spawn communicates with the databases Spawn\ngenerates data for. As Spawn is developed using Javascript, Spawn will\ncapitalize on the robust <a href="http://docs.sequelizejs.com/">Sequelize</a> ORM to\nperform its database transactions.</p>\n<h2>5. Spawn: Graph model</h2>\n<p>Spawn utilizes a graph model to determine the data generation priority between\ntables. Steps 1-3 detail how the graph model is produced while steps 4-7 detail\nhow the graph model is used in determining data generation priority.</p>\n<ol>\n<li>Each table is modelled by a node</li>\n<li>If a table (T1) is generated based on data available in another table (T2),\nwe call T1 a consumer of T2\'s data. A consumer relationship is modelled by a\ndirected edge originating from the consumer and pointing towards the\nproducer.</li>\n<li>Spawn prevent the formation of any closed cycles in the graph model. This\nprevents cyclic data dependencies.</li>\n<li>When it is time to generate data, generate any table with no outgoing\ndirected edge (Non-consumer). The prevention of closed cycles in step 3\nguarantees that there is at least one Non-consumer table.</li>\n<li>Repeat step 4 until there are no more Non-consumer tables.</li>\n<li>Generate a consumer table that only consume fully generated producers.</li>\n<li>Repeat step 6 until there are no more tables to be generated.</li>\n</ol>\n<p><strong>&#x3C;WILL INCLUDE: Figures 5a and 5b illustrates a database schema and its\nassociated graph model.></strong></p>\n<p>Spawn\'s graph model borrows its design from the graph models proposed by [Bruno\n&#x26; Chaudhari, 2005] and [Houkjaer et al, 2006]. Table 5a details where the three\nmodels converge and diverge.</p>\n<p><u>Table 5a</u></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Houkjaer et al, 2006</th>\n<th>Bruno &#x26; Chaudhari, 2005</th>\n<th>Spawn</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Priority</strong></td>\n<td>Determines data generation priority between tables</td>\n<td>Determines data generation priority between tables and columns</td>\n<td>Determines data generation priority between tables</td>\n</tr>\n<tr>\n<td><strong>Nodes</strong></td>\n<td>Nodes carry table data</td>\n<td>Nodes carry table data</td>\n<td>Nodes carry table data</td>\n</tr>\n<tr>\n<td><strong>Edges</strong></td>\n<td>Three types of directed edges</td>\n<td>One type of directed edge</td>\n<td>One type of directed edge</td>\n</tr>\n<tr>\n<td><strong>Edge data</strong></td>\n<td>Edges carry information on foreign keys and cardinality distributions</td>\n<td>Edges carry no information</td>\n<td>Edges carry information on foreign keys and cardinality distributions</td>\n</tr>\n</tbody>\n</table>\n<h2>6. Graphical design</h2>\n<p>Spawn\'s GUI attempts to make the task of configuring data generators as simple\nas possible. The GUI is written in Electron, and powered using the React\nfrontend library.</p>\n<h3>6.1 Overall layout</h3>\n<p><u>Figure 6a: Spawn\'s GUI\'s overall layout</u></p>\n<p><img src="https://aaronong.github.io/SpawnUI.png" alt="Spawn GUI"></p>\n<p>The GUI consists of four main components listed from left to right:</p>\n<ul>\n<li>\n<p>The Navigation Bar is the leftmost graphical component. It allows users to\nswitch between various task categories quickly. The navigation bar is laid out\nvertically along the left instead of horizontally along the top to conserve\nthe scarce vertical real-estate of the landscape view. The following task\ncategories are listed on the navigation bar.</p>\n<ul>\n<li>Schema - Allows users to configure their database schema through a graphical\ninterface.</li>\n<li>Graph - Allows users to visually inspect how their database\'s graph model\nlooks like.</li>\n<li>FVGs - One category for each type of FVG. Allows users to test different\nFVGs before incorporating them into their data generator.</li>\n<li>Extension store - Where users are able to browse and install FVGs developed\nby other users.</li>\n<li>Settings - Where users are able to deal with Spawn\'s configuration.</li>\n</ul>\n</li>\n<li>The Category Explorer allows users to navigate effectively within a category.</li>\n<li>The Main Editor takes centrestage in Spawn\'s GUI. The tabs located at the top\nof the main editor allow users to quickly navigate between the various tabs\nthey have open on Spawn. The Panes below the tabs are where majority of the\nvisualizations offered by Spawn are rendered.</li>\n<li>The Properties Explorer is where most of the configurations are managed.</li>\n</ul>\n<h3>6.2 Specific visualizations</h3>\n<p>While the GUI has not been fully developed, this subsection will detail how\nSpawn\'s GUI will look like on a category level.</p>\n<h4>6.2.1 Schema Visualization</h4>\n<p><u>Figure 6b: A design inspiration for how Spawn\'s schema category could look\nlike</u></p>\n<p><img src="https://lh3.googleusercontent.com/-Roupw0Z50TY/WfLw3oAr6aI/AAAAAAAApQw/DXqev79BGN8wwUoWf-OwAhBHm7evf6_EgCLcBGAs/s0/sqldbm.png" alt="sqlDBM"></p>\n<p>The schema visualization tab will allow developers to configure their database\nmodel based on a graphical user interface. Clicking any of the tables in the\nMain Editor will populate a different view on the Properties Explorer where\nconfigurations for the specific table will be managed.</p>\n<h4>6.2.2 Graph Visualization</h4>\n<p>The graph visualization tab offers a view similar to the Schema visualization\ntab with a few key differences:</p>\n<ul>\n<li>Tables are replaced by nodes</li>\n<li>Relations are replaced by directed edges</li>\n<li>Data Generation details are configured in place of the database model.</li>\n</ul>\n<h4>6.2.3 Boolean Visualization</h4>\n<p>The Boolean visualization tab displays a simple pie chart in the Main Editor to\nvisualize the percentage of true and false booleans generated by a specific\nBoolean FVG under certain input conditions. The GUI runs the Boolean FVG ten\nthousand times to generate a representative sample. The input details are\nconfigured on the Properties Explorer.</p>\n<p>For instance, a Boolean FVG that takes in an individual\'s "Country" as an input\nto generate the likelihood of the individual being retired is going to show\ndifferent pie chart if "China" is keyed in as opposed to "Japan".</p>\n<h4>6.2.4 Numerical Visualization</h4>\n<p>The Numerical Visualization tab displays two graphs on the main canvas for users\nto visualize output of a specific Numerical FVG: a cumulative distribution\nfunction (CDF) and a probability density function (PDF) of the Numerical FVG.\nSimilar to the Boolean Visualization, the GUI runs the Numerical FVG ten\nthousand times to generate a representative sample that it then uses to plot the\nCDF and PDF graphs. The FVG\'s inputs are also configured in the Properties\nExplorer.</p>\n<h4>6.2.5 String Visualization</h4>\n<p>The String Visualization tab displays two items on the main canvas for users to\nvisualize the output of a specific String FVG: a stringcloud, and a string\nfrequency list generated by the String FVG. Similar to the Boolean\nVisualization, the GUI runs the String FVG ten thousand times to generate a\nrepresentative sample that it then uses to form the string frequency list and\nstringcloud.</p>\n<h4>6.2.6 Datetime Visualization</h4>\n<p>The main canvas displays several charts that users are able to switch between:</p>\n<ul>\n<li>Line graph of time series data</li>\n<li>Pie chart by Hour of day</li>\n<li>Pie chart by Day of week</li>\n<li>Pie chart by Month</li>\n<li>Pie chart by Year</li>\n</ul>\n<h2>7. Generating data quickly</h2>\n<p>CDG generates batches of data one field at a time to maximize the cache hits on\nthe CPU\'s Translation Lookaside Buffer (TLB) for hardware optimization.</p>\n<p>When generating data within a record, CDG simply retrieves the required input\nfields (recently generated) from the memory.</p>\n<p>When generating data across associations, CDG opts to generating a local copy of\nthe parent record instead of pulling the data from the database. Generating a\nlocal record is faster than seeking for information through a network given that\nthe PRNG used in CDG is able to generate the nth random number in the RNG\nsequence within log (n) time.</p>\n<h2>8. Comparison</h2>\n<h2>9. Academic References</h2>\n<h3>9.1 Data Generators</h3>\n<ul>\n<li>\n<p><a href="https://dl.acm.org/citation.cfm?id=191886"><strong>Quickly generating billion-record synthetic databases - 333 citations,\n1994, Gray et al</strong></a></p>\n<ul>\n<li>Father of all Data gen papers. Abit old, talk alot about OS, but addresses\nkey concerns regarding how to generate data in a parallel fashion with a\nshared-nothing architecture.</li>\n</ul>\n</li>\n<li>\n<p><a href="https://pdfs.semanticscholar.org/c17c/7d621e90a43045094b8f8c8b66702e9cf31b.pdf"><strong>New TPC Benchmarks for Decision Support and Web Commerce - x citations,\n2000, Poess and\nFloyd</strong></a></p>\n<ul>\n<li>Introduces a couple of TPC benchmarks</li>\n</ul>\n</li>\n<li>\n<p><a href="https://dl.acm.org/citation.cfm?id=974060&#x26;CFID=822130322&#x26;CFTOKEN=79390160"><strong>MUDD: A Multi-Dimensional Data Generator - 24 citations, 2004, Stephens &#x26;\nPoess</strong></a></p>\n<ul>\n<li>Provides history of data generators</li>\n</ul>\n</li>\n<li>\n<p><a href="https://dl.acm.org/citation.cfm?id=1083592.1083719"><strong>Flexible Database Generators - 40 citations, 2005, Bruno &#x26;\nChaudhuri</strong></a></p>\n<ul>\n<li>Introduces Data Generation Language(DGL) a domain specific language for data\ngeneration.</li>\n<li>Argues for data generation to follow a Direct Acyclic Graph, eg. if\nfirstName data, depends on lastName data, lastName cannot depend on\nfirstName data.</li>\n</ul>\n</li>\n<li>\n<p><a href="https://dl.acm.org/citation.cfm?id=1164254&#x26;CFID=822130322&#x26;CFTOKEN=79390160"><strong>Simple and realistic data generation - 38 citations, 2006, Houkjaer et\nal</strong></a></p>\n<ul>\n<li>Introduces a new data generation tool, its architecture, and graph model.</li>\n<li>Inter-row dependencies also exist, like uber\'s polling of driver location.</li>\n</ul>\n</li>\n<li>\n<p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?rep=rep1&#x26;type=pdf&#x26;doi=10.1.1.206.1622"><strong>A Data Generator for Cloud-Scale Benchmarking - 21 citations, 2010, Rabl et\nal</strong></a></p>\n<ul>\n<li>Introduces an ubiquitous parallel data generation framework (PDGF) that is\nsuitable for cloud scale data generation.</li>\n</ul>\n</li>\n<li>\n<p><a href="https://dl.acm.org/citation.cfm?id=1989395"><strong>Data generation using declarative constraints - 14 citations, 2011, Arasu\net al</strong></a></p>\n<ul>\n<li>Argues that cardinality constraints are a natural, expressive, and\ndeclarative mechanism for specifying data characteristics.</li>\n<li>Discusses how Linear Programming (LP) solvers can be used in conjunction\nwith cardinality constraints for natural (user-friendly) data generation.</li>\n</ul>\n</li>\n<li>\n<p><a href="https://dl.acm.org/citation.cfm?id=2367530"><strong>Myriad: scalable and expressive data generation - 21 citations, 2012,\nAlexandrov et al</strong></a></p>\n<ul>\n<li>Introduces Pseudo-Random Data Generation (PDRG) an algorithm that improves\nupon PDGF\'s SeedSkip algorithm to generate data more optimally.</li>\n<li>Leverages random access of the produced pseudo-random number sequence to\noptimize data generation.</li>\n</ul>\n</li>\n<li>\n<p><a href="https://dl.acm.org/citation.cfm?id=2479445&#x26;CFID=822130322&#x26;CFTOKEN=79390160"><strong>Reversing statistics for scalable test databases generation - 2 citations,\n2013, Shen &#x26;\nAntova</strong></a></p>\n<ul>\n<li>Proposes RSGEN a data generation algorithm that leverages a source\ndatabase\'s metadata to generate a scaled-up version. (only handles numerical\ndata)</li>\n</ul>\n</li>\n<li>\n<p><a href="https://dl.acm.org/citation.cfm?id=2479441&#x26;CFID=822130322&#x26;CFTOKEN=79390160"><strong>Rapid development of data generators using meta generators in PDGF - 2\ncitations, 2013, Rabl et\nal</strong></a></p>\n<ul>\n<li>Proposes the use of an XML based meta-generator that can be parsed to\ndeterministically generate identical data.</li>\n</ul>\n</li>\n<li>\n<p><a href="https://dl.acm.org/citation.cfm?id=2735378&#x26;CFID=822130322&#x26;CFTOKEN=79390160"><strong>Just can\'t get enough: Synthesizing Big Data - 3 citations, 2015, Rabl et\nal</strong></a></p>\n<ul>\n<li>Introduces DBSynth, an improvement upon RSGEN that is able to handle more\nthan numerical data.</li>\n</ul>\n</li>\n</ul>\n<h3>9.2 Random Number Generation</h3>\n<ul>\n<li>\n<p><a href="http://www.pcg-random.org/pdf/hmc-cs-2014-0905.pdf"><strong>PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms\nfor Random Number Generation, 2014,\nO\'Neill</strong></a></p>\n<ul>\n<li>Introduces the Permuted Congruential Generator(PCG) family of RNG algorithms</li>\n<li>based off the Linear Congruential Generator (LCG) algorithm.</li>\n</ul>\n</li>\n<li>\n<p><a href="http://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf"><strong>TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD\nLATTICE STRUCTURE - 234 citations, 1999,\nL\'ecuyer</strong></a></p>\n<ul>\n<li>Provides good multiplicative constants to be used with the LCG algorithm.</li>\n</ul>\n</li>\n<li>\n<p><a href="https://laws.lanl.gov/vhosts/mcnp.lanl.gov/pdf_files/anl-rn-arb-stride.pdf"><strong>Random Number Generation with Arbitrary Strides - 9 citations, 1994, Brown\net\nal</strong></a></p>\n<ul>\n<li>Provides a formula to retrieve the <em>nth</em> number of an LCG sequence in\nlog(<em>n</em>) time.</li>\n</ul>\n<p>â€‹ â€‹</p>\n</li>\n</ul>',frontmatter:{date:"November 24, 2017",path:"spawn",title:"Spawn: A simple tool for generating realistic data"}}},pathContext:{id:"spawn"}}}});
//# sourceMappingURL=path---blog-spawn-231f0ee21c9f78f681a3.js.map